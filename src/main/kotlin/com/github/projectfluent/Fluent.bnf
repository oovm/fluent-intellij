{
    parserClass = "com.github.projectfluent.language.parser.FluentParser"
    parserUtilClass = "com.github.projectfluent.language.psi.FluentParserExtension"

    extends = "com.github.projectfluent.language.psi.FluentElement"

    psiClassPrefix = "Fluent"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.projectfluent.language.psi"
    psiImplPackage = "com.github.projectfluent.language.psi_node"

    elementTypeHolderClass = "com.github.projectfluent.language.psi.FluentTypes"
    elementTypeClass = "com.github.projectfluent.language.psi.FluentElementType"
    tokenTypeClass = "com.github.projectfluent.language.psi.FluentTokenType"

    psiImplUtilClass = "com.github.projectfluent.language.psi_node.FluentPsiExtension"

    tokens = [
        // comment
        COMMENT_DOCUMENT = "Comment Document"
        COMMENT = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL = "Symbol"
        STRING_QUOTE = "String Quote"
        STRING_CHAR = "String Character"
        STRING_ESCAPE = "String Escaped"

        BYTE = 'regexp:(0[bBoOxXfF][0-9A-Fa-f][0-9A-Fa-f_]*)'
        INTEGER = 'regexp:(0|[1-9][0-9_]*)'
        DECIMAL = 'regexp:([0-9]+\.[0-9]*([*][*][0-9]+)?)|(\.[0-9]+([Ee][0-9]+)?)'
        SIGN = 'regexp:[+-]'
        TEXT_CHAR="Text Character"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        ACCENT = '^'
        EQ = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        STAR = '*'
        AT = '@'
//      SPACE='regexp:\s+'
//      ANY = 'regexp:.'
    ]
}

// https://github.com/projectfluent/fluent/blob/master/spec/fluent.ebnf
Fluent ::= fluent_item*;
/* An FTL file defines a Resource consisting of Entries. */
private fluent_item ::=
	Message
	|Term
//	| CommentLine
	;

/* Entries are the main building blocks of Fluent. They define translations and
 * contextual and semantic information about the translations. During the AST
 * construction, adjacent comment lines of the same comment type (defined by
 * the number of #) are joined together. Single-# comments directly preceding
 * Messages and Terms are attached to the Message or Term and are not
 * standalone Entries. */

Message   ::= identifier EQ  ((pattern attribute*) | (attribute+))
Term      ::= "-" identifier EQ pattern attribute*
// Attributes of Messages and Terms.
attribute ::= "." identifier EQ pattern
// Patterns are values of Messages, Terms, Attributes and Variants.
pattern   ::= pattern_element+
private pattern_element ::=
	inline_text
//	| block_text
//	| inline_placeable
//	| block_placeable
/* TextElement and Placeable can occur inline or as block.
 * Text needs to be indented and start with a non-special character.
 * Placeables can start at the beginning of the line or be indented.
 * Adjacent TextElements are joined in AST creation. */

inline_text         ::= TEXT_CHAR+
//block_text          ::= blank_block blank_inline indented_char inline_text?
//inline_placeable    ::= "{"   (SelectExpression | InlineExpression)   "}"
//block_placeable     ::= blank_block   inline_placeable



/* Adjacent comment lines of the same comment type are joined together during
 * the AST construction. */
//CommentLine         ::= ("###" | "##" | "#") ("\u0020" comment_char*)? line_end

/* Junk represents unparsed content.
 *
 * Junk is parsed line-by-line until a line is found which looks like it might
 * be a beginning of a new message, term, or a comment. Any whitespace
 * following a broken Entry is also considered part of Junk.
 */
//Junk                ::= junk_line (junk_line - "#" - "-" - [a-zA-Z])*
//junk_line           ::= /[^\n]*/ ("\u000A" | EOF)






/* Rules for validating expressions in Placeables and as selectors of
 * SelectExpressions are documented in spec/valid.md and enforced in
 * syntax/abstract.js. */
//InlineExpression    ::= StringLiteral
//                      | NumberLiteral
//                      | FunctionReference
//                      | MessageReference
//                      | TermReference
//                      | VariableReference
//                      | inline_placeable

/* Literals */
string       ::= STRING_QUOTE (STRING_CHAR|STRING_ESCAPE)* STRING_QUOTE;
//NumberLiteral       ::= "-"? digits ("." digits)?
/* Identifier */
identifier          ::= SYMBOL;

/* Inline Expressions */
//FunctionReference   ::= Identifier CallArguments
//MessageReference    ::= Identifier [AttributeAccessor]
//TermReference       ::= "-" Identifier [AttributeAccessor] [CallArguments]
//VariableReference   ::= "$" Identifier
//AttributeAccessor   ::= "." Identifier
//CallArguments       ::=   "("   argument_list   ")"
//argument_list       ::= (Argument   ","  )* [Argument]
//Argument            ::= NamedArgument | InlineExpression
//NamedArgument       ::= Identifier   ":"   (StringLiteral | NumberLiteral)

/* Block Expressions */
//SelectExpression    ::= InlineExpression   "->"   variant_list
//variant_list        ::= Variant* DefaultVariant Variant* line_end
//Variant             ::= line_end   VariantKey   Pattern
//DefaultVariant      ::= line_end   "*" VariantKey   Pattern
//VariantKey          ::= "["   (NumberLiteral | Identifier)   "]"



